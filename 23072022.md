### Callback 함수

<img width="836" alt="스크린샷 2022-07-23 09 08 53" src="https://user-images.githubusercontent.com/92393851/180594665-85f7b158-d17f-44c5-b83e-180ffce1ac2c.png">

> 함수 안에 파라미터로 들어가는 함수를 콜백함수라고 한다. 콜백함수는 function() {}이 아니라 함수명() 으로만 들어가도 무방함!

* Hoisting : var (TDZ의 보호를 받고 있지 않은)를 사용하면 호이스팅이 일어나 변수의 값이 언제 바뀔지 모르니 좋지 않다.

* 동기(Sync)와 비동기 (Async)에 대한 개념 

  동기로 실행된다 -> 먼저 실행된 코드의 결과가 나올 때까지 대기 (ex)놀이공원)
  비동기로 실행된다 -> 실행되니 순서와 관계 없이 결과가 나온다 (ex) 음식점)
  
* Blocking/non blocking

  Blocking model : 코드의 실행이 끝나기 전까지 제어권을 넘기지 않아, 다른 작업 못하고 대기
  Non blocking model : 코드이 실행이 끝나지 않아도 실행 제어권을 다른 곳에 넘겨 다음 코드 실행 시킴
  
  -> 제어권을 넘기면 Non blocking, 비동기 처리가 가능 
  제어권을 넘기지 않으면 비동기 처리가 가능한 환경이라도 비동기 처리 불가능

> JS는 비동기와 non blocking	: 실행 중인 코드의 실행이 끝나지 않아도 다음 코드를 호출 (모든 함수는 비동기적으로 실행됨)

```javascript
function first() {
  console.log('First');} // 마지막으로 출력

setTimeout(first, 1000); // 1000ms(1초) 뒤에 first 함수를 실행해준다.

console.log('Middle'); // 첫번째로 출력
console.log('Last'); // 두번째로 출력
```

Non blocking model이 아니었다면 1초 기다린 후 First-> Middle-> Last 순서로 출력

* Promise : js에서 비동기 처리를 동기로 처리할 수 있게 돕는 객체로 3가지의 대기/이행/거부의 상태가 있다. 

대기 Pending : 이행하거나, 거부되지 않은 초기 상태
이행 Fulfilled : 연산이 성공적으로 완료됨
거부 Rejected : 연산이 실패함 

executor에는 함수만 올 수 있으며 인자로 resolve, reject가 주입

```
new Promise(executor); new Promise ((resolve, reject) => {});
```
-> promise가 만들어질때 executor가 실행되며, executor에서 resolve 함수가 호출되기 전까지 firstPromise.then(...)안에 있는 코드 실행 X

-> Promise 안에서 에러가 throw되거나 reject되면 catch 메소드에 작성한 함수가 실행됨.

-> Promise.then (추가 설명)


* 비동기 함수 (Async Function) : 비동기 함수의 결과는 항상 Promise 객체로 resolve/ 비동기 함수 안에서만 await 연산자를 사용 가능!
```
// 비동기 + 일반 함수
async function 함수이름() {명령문}

// 비동기 + 익명 함수
async function() {명령문}

// 비동기 + 화살표 함수
async () => {명령문}
```
모든 함수 결과는 Promise

- new Promise(executor) 코드로 프로미스를 직접 생성하면 executor가 바로 실행되는것과 달리, 비동기 함수는 함수가 실행되기 전까지 프로미스를 생성하지 않음

* await 연산자 : ansync 함수에서만 사용 가능하며, promise가 fulfill되거나 rejected 될때까지 함수의 실행을 중단하고 기다릴수 있고, Promise 연산이 끝나면 반환한 값을 얻을 수 있음

```
const result = await 값; //'값'에는 promise가 아닌 다른 값도 들어갈 수 있고, 해당 값을 바로 반환
```

```
async function 함수이름() {
  const result = await 'Test!';
  console.log (result);}
  
함수이름(); // 'Test!'
```

---

### Q. 생년월일을 입력받아 만 나이 계산하는 함수 작성, 20세 미만 출력하는 함수 작성
-> 현재 년도에서 출생 년도를 뺀후, 생일이 지나지 않았으면 1살 빼기.
```javascript
function getAge(dateOfBirth) {
    const today = new Date(); //오늘 날짜+시간 가져오기
    const birthDate = new Date(dateOfBirth); //생일을 date 객체로 저장
    
    console.log(birthDate); //1990-01-01T15:27:00.000Z

    let age = today.getFullYear() - birthDate.getFullYear(); //32
    const m = today.getMonth() - birthDate.getMonth(); //6
    console.log(age, m);
    if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
    age--; //생일이 지나지 않았으면 -1
    } return age;
}
console.log(getAge('1990-01-01 16:27:00'));
```


---

### Q. restAPI의 put 과 patch 는 어떤 차이점이 있을까요? 어떤 경우에 사용하면 좋을까요?


---

const result = New promise((resolve, reject)=>{}); //화살표 함수
비동기를 간편하게 처리할 수 있도록 도와주는 object
- State: pending -> fulfilled or rejected

* Producer/consumer
- Producer **새로운 promise가 만들어지면 executor가 바로 실행된다.**
const promise = new promise (resolve, reject) => {
Console.log(‘doing something….’} // heavy work()
시간이 좀 많이 걸리는 일들은 이렇게 promise를 만들어서 다른 것들 먼저 진행될 수 있도록 (비동기) promise 를 쓴다. Ex) network, read files.. 
